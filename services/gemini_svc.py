import vertexai
from vertexai.generative_models import GenerativeModel, GenerationConfig, Part
from tenacity import retry, wait_random_exponential
from config import PROJECT_ID, REGION2, MODEL_NAME
from utils import get_current_date

vertexai.init(project=PROJECT_ID, location=REGION2)

model = GenerativeModel(MODEL_NAME)

expense_schema = {
        "type": "OBJECT",
        "properties": {
            "currency": {"type": "STRING"},
            "price": {"type": "NUMBER"},
            "category": {"type": "STRING"},
            "description": {"type": "STRING"},
            "date": {"type": "STRING"},
        },
}

expense_config = GenerationConfig(temperature=0.2,
                                  response_mime_type="application/json",
                                  response_schema=expense_schema)

# function to call gemini to process expense text
# implement exponential backoff for load handling
@retry(wait=wait_random_exponential(multiplier=1, max=60))
async def process_expense_text(input_text: str):
    """parses expense details from plain text input
    Args:
        input_text (str) : user input
    Returns:
        response.text (str) : text generated by LLM with json structure
    """

    today, day = get_current_date()

    prompt = f"""
    Extract structured expense details from this text: {input_text}. 
    
    Today's date is {today}. Today is {day}. Extrapolate the expense date based on today's date.
    
    Important instructions for each field: 
    CURRENCY (if unspecified, default is SGD. Assume that $ is SGD, not USD. Make sure to return only the 3-letter symbol (example: GBP, SGD, EUR, JPY, MYR, RMB));
    PRICE;
    CATEGORY (think about what it should be based on the item or place provided. Keep to 1 word if possible);
    DESCRIPTION (this can just be the place or store name, if specified. If a shop name is not specified or is unclear, be more detailed in the description, 
    but make sure to only include whatever is already in the user input.); 
    DATE (be extra careful if the user inputs terms like "last Tuesday" or "last Monday". Count backwards carefully to find the exact date from today's date).
    """
    response = await model.generate_content_async(
        contents=prompt, generation_config=expense_config
    )
    return response.text

# function to call gemini to process expense (e.g. receipt) image
# implement exponential backoff for load handling
@retry(wait=wait_random_exponential(multiplier=1, max=60))
async def process_expense_image(image_path: str, caption: str=None):
    """parses expense details from image input
    Args:
        - image_path (str) : path to image sent by user
        - caption (str) : caption accompanying image for further instructions. Defaults to None
    Returns:
        response.text (str): text generated by LLM with json structure
    """

    today, day = get_current_date()

    prompt = f"""
    Extract structured expense details from the image and provided image caption.

    IMPORTANT - Image caption: {caption or "No caption provided"}

    Use the caption as an additional source of information when determining expense details.
    
    Instructions:
    - Look for the TOTAL amount (usually near the bottom, labeled as "TOTAL", "GRAND TOTAL", "AMOUNT DUE", etc.).
    - Today's date is {today}. Today is {day}. Extrapolate the expense date based on today's date. 
    - Use receipt date if available; otherwise, infer a reasonable date based on context.
    - Be extra careful if the user inputs terms like "last Tuesday" or "last Monday". Count backwards carefully to find the exact date from today's date.
    - For currency, default to SGD if unspecified. Assume $ means SGD unless context suggests otherwise.
    - Make sure to return only the 3-letter symbol (example: GBP, SGD, EUR, JPY, MYR, RMB).
    - For description, use the store/vendor name or a summary of the main purchase.
    - For category, determine a suitable category based on the vendor or purchased items.
    """

    with open(image_path, "rb") as img_file:
        image_bytes = img_file.read()

    image_part = Part.from_data(
        mime_type="image/png",
        data=image_bytes
    )

    response = await model.generate_content_async(
        contents=[image_part, prompt],
        generation_config=expense_config
    )
    return response.text

# function to refine extracted expense details
# implement exponential backoff for load handling
@retry(wait=wait_random_exponential(multiplier=1, max=60))
async def refine_expense_details(original_details, user_feedback):
    """Refines the parsed expense details based on user corrections.
    Args:
        - original_details (dict) : originally parsed expense details in json format
        - user_feedback (str) : user-provided feedback for requested changes
    Returns:
        - response.text (str) : text generated by LLM with json structure
    """
    prompt = f"""
    Here are the originally parsed expense details:
    {original_details}
    
    The user has provided the following feedback for correction:
    {user_feedback}
    
    Please refine the expense details accordingly while keeping other details unchanged.
    """
    response = await model.generate_content_async(
        contents=prompt, generation_config=expense_config
    )
    return response.text
